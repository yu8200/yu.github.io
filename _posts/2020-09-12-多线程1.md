---
layout: post
title: 多线程一 
categories: [ios]
tags: [ios]
description: Thread 
---


<h1>常见的多线程方案</h1>

{% highlight ruby %}
pthread      通用的多线程API，下面三种都是基于它的封装
NSThread   面向对象，简单易用
GCD       替代NSThread,能利用设备的多核
NSOperation    基于GCD，面向对象，比GCD多了一些更简单实用的功能

{% endhighlight %}

<h1>同步、异步、并发、串行</h1>
<p>同步和异步主要影响：能不能开启新的线程</p>
<p>同步：在当前线程中执行任务，不具备开启新线程的能力</p>
<p>异步：在新的线程中执行任务，具备开启新线程的能力。（主线程除外）</p>

<p>并发：多个任务同时执行</p>
<p>串行：一个任务执行完毕后，再执行下一个任务</p>

<h1>主队列，串行队列，并行队列</h1>
<p>主队列属于特殊队列，所以，在asyn时，虽然具备开启新线程能力，但是在主线程，不会开启新线程</p>

<p>如果没有开启线程的能力，无论什么队列，都只能串行执行</p>
<p>如果有开启线程的能力，异并并，异串串，异主串</p>


<p>死锁问题</p>
<p>
串行队列：只能按顺序一个一个出
并发队列：没有顺序，一次可出多个。
asyn:开启新线程去队列中取出任务执行
syn：立即去队列中取出任务执行

1、查看当前是asyn还是syn，判断是不是开启新线程
2、查看队列类型，串行还是并发？
代码从按顺序执行，根据上面2个条件去取对应的任务执行。

符合下面2个条件，就会死锁
1、aync
2、往当前的串行队列添加任务

</p>

<p>子线程默认不开启runloop,而nstimer都跟需要runloop</p>

<p>异步执行A,B个任务，等待AB三个全部执行完后，再执行C任务</p>

{% highlight ruby %}

dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_queue_create("myquque", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_async(group, queue, ^{
    NSLog(@"AAA-%@",[NSThread currentThread]);
});
dispatch_group_async(group, queue, ^{
    NSLog(@"BB-%@",[NSThread currentThread]);
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@"CC-%@",[NSThread currentThread]);
});

{% endhighlight %}

<h1>线程同步锁有哪些<h2>
<p>OSSpinLock</p>
<p>os_unfair_lock</p>
<p>pthread_mutex</p>
<p>dispatch_semaphore</p>
<p>dispatch_queue</p>
<p>NSLock</p>
<p>NSRecursiveLock</p>
<p>NSCondition</p>
<p>NSConditionLock</p>
<p>@synchronized</p>


<h1>OSSpinLock<h2>
<p>
1、OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<p>
2、目前已经不再安全，可能会出现优先级反转问题
如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁
</p>
<p>1、#import <os/lock.h></p>
<p>2、@property(nonatomic,assign)OSSpinLock lock;</p>
<p>//全局初始化锁</p>
<p>3、self.lock = OS_SPINLOCK_INIT;</p>

{% highlight ruby %}

 //加锁
 OSSpinLockLock(&_lock);
 //需要加锁的代码
 //解锁
 OSSpinLockLock(&lock);
{% endhighlight %}
